<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Infographic Editor</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&display=swap" rel="stylesheet">

  <style>
    * { box-sizing: border-box; }

    :root{
      --accent: #3871E1;
      --accentAlpha0: rgba(56,113,225,0);
    }

    body{
      margin:0;
      min-height:100vh;
      background:#1b1b1b;
      color:#fff;
      font-family: system-ui, sans-serif;
      padding: 28px 16px;
    }

    .layout{
      display:flex;
      gap: 18px;
      align-items:flex-start;
      justify-content:center;
      width: 100%;
    }
    @media (max-width: 1100px){
      .layout{ flex-direction: column; align-items:center; }
    }

    /* EXPORTABLE CARD */
    .card{
      position: relative;
      width: 721px;
      height: 721px;
      background: #0F0F0F;
      overflow: hidden;
      flex: 0 0 auto;
    }

    /* --- Animations texte (apparition) --- */
    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(12px); filter: blur(2px); }
      to   { opacity: 1; transform: translateY(0);   filter: blur(0); }
    }
    @keyframes popIn {
      0%   { opacity: 0; transform: scale(.985); filter: blur(2px); }
      100% { opacity: 1; transform: scale(1);    filter: blur(0); }
    }

    /* Classe d’animation “default” */
    .anim-in {
      animation: fadeUp 520ms ease both;
      will-change: transform, opacity, filter;
    }

    /* Variante “pop” (si tu veux tester, remplace anim-in par anim-pop dans le HTML) */
    .anim-pop {
      animation: popIn 420ms ease both;
      will-change: transform, opacity, filter;
    }

    /* Stagger au chargement : titre puis valeur */
    .title.anim-in { animation-delay: 60ms; }
    .value.anim-in { animation-delay: 140ms; }

    .title{
      position:absolute;
      top: 48px;
      left: 48px;

      color: #FFF;
      font-family: "Funnel Display", system-ui, sans-serif;
      font-size: 80px;
      font-weight: 400;
      line-height: 81.5px;
      margin: 0;
      white-space: pre-line;

      z-index: 2; /* sous la jauge */
    }

    .value{
      position:absolute;
      left: 48px;
      bottom: 48px;

      display:flex;
      width: 552px;
      height: 171px;
      flex-direction: column;
      justify-content: center;

      color:#FFF;
      font-family: "Roboto Mono", monospace;
      font-size: 240px;
      font-weight: 400;
      line-height: 121.5px;
      letter-spacing: -6px;
      margin: 0;

      z-index: 1; /* sous la jauge */
    }

    .gauge{
      position:absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);

      width: 522px;
      height: 522px;

      pointer-events:none;
      z-index: 3;
      filter: drop-shadow(0 18px 28px rgba(0,0,0,.55));
    }

    #sector{ transition: d 220ms ease, opacity 160ms ease; }
    #fullCircle{ transition: opacity 160ms ease; }

    /* CONTROLS */
    .panel{
      background: rgba(10,12,16,.55);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 16px;
      backdrop-filter: blur(8px);

      width: 380px;
      max-width: 92vw;
    }

    .panelTitle{
      font-size: 14px;
      font-weight: 600;
      letter-spacing: .2px;
      margin: 2px 0 14px;
      color: rgba(255,255,255,.9);
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .row.full{
      justify-content: stretch;
      align-items:flex-start;
    }
    .row.full .label{ margin-top: 10px; }

    .label{
      font-size: 12px;
      color: rgba(255,255,255,.65);
      letter-spacing:.3px;
      width: 58px;
      text-align:right;
    }

    input[type="range"]{ width: 220px; }
    input[type="number"], input[type="text"]{
      background:#111;
      border:1px solid rgba(255,255,255,.2);
      color:#fff;
      padding:8px 10px;
      border-radius:10px;
      outline:none;
      font-size:14px;
    }
    input[type="number"]{ width: 86px; text-align:right; }
    input[type="text"]{ width: 100%; }

    button{
      background:#111;
      border:1px solid rgba(255,255,255,.25);
      color:#fff;
      padding:8px 12px;
      border-radius:10px;
      cursor:pointer;
      font-size:14px;
    }
    button[disabled]{ opacity:.55; cursor:not-allowed; }

    .swatches{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap: wrap;
    }
    .swatch{
      width: 22px;
      height: 22px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.22);
      cursor: pointer;
      outline: none;
    }
    .swatch[aria-selected="true"]{
      box-shadow: 0 0 0 2px rgba(255,255,255,.85);
      border-color: transparent;
    }

    .hint{
      font-size: 12px;
      color: rgba(255,255,255,.5);
      text-align:right;
      margin-top: 2px;
    }
    .status{
      font-size: 12px;
      color: rgba(255,255,255,.55);
      text-align:right;
      min-height: 16px;
    }
  </style>
</head>

<body>

  <div class="layout">
    <!-- LEFT: EXPORTABLE VISUAL -->
    <div class="card" id="exportArea">
      <h1 class="title anim-in" id="titleText">Security<br>rating</h1>
      <p class="value anim-in" id="valueWrap"><span id="pctText">80%</span></p>

      <svg class="gauge" viewBox="0 0 300 300" aria-label="Gauge">
        <defs>
          <radialGradient id="fillRadial" cx="50%" cy="50%" r="50%">
            <stop offset="0%" stop-color="var(--accentAlpha0)" />
            <stop offset="100%" stop-color="var(--accent)" />
          </radialGradient>

          <filter id="soften" x="-20%" y="-20%" width="140%" height="140%">
            <feGaussianBlur stdDeviation="0.15" />
          </filter>
        </defs>

        <circle id="fullCircle" cx="150" cy="150" r="140"
                fill="url(#fillRadial)" filter="url(#soften)" opacity="0"></circle>

        <path id="sector" d="" fill="url(#fillRadial)" filter="url(#soften)"></path>
      </svg>
    </div>

    <!-- RIGHT: CONTROLS -->
    <div class="panel">
      <div class="panelTitle">Controls</div>

      <div class="row">
        <div class="label">%</div>
        <input id="range" type="range" min="0" max="100" value="80">
        <input id="num" type="number" min="0" max="100" value="80">
      </div>

      <div class="row full">
        <div class="label">Titre</div>
        <input id="titleInput" type="text" value="Security\nrating">
      </div>

      <div class="row">
        <div class="label">Couleur</div>
        <div class="swatches" id="swatches"></div>
      </div>

      <div class="row">
        <div class="label">Export</div>
        <button id="btnPng">PNG</button>
        <button id="btnJpg">JPG</button>
      </div>

      <div class="hint">Astuce : retour à la ligne avec \n</div>
      <div class="status" id="status"></div>
    </div>
  </div>

  <!-- html-to-image (export fiable avec SVG/gradients) -->
  <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.min.js"></script>

  <script>
    const exportArea = document.getElementById('exportArea');
    const sector = document.getElementById('sector');
    const fullCircle = document.getElementById('fullCircle');
    const pctText = document.getElementById('pctText');
    const valueWrap = document.getElementById('valueWrap');
    const range = document.getElementById('range');
    const num = document.getElementById('num');
    const titleText = document.getElementById('titleText');
    const titleInput = document.getElementById('titleInput');
    const btnPng = document.getElementById('btnPng');
    const btnJpg = document.getElementById('btnJpg');
    const statusEl = document.getElementById('status');
    const swatchesEl = document.getElementById('swatches');

    const palette = [
      { name: "Blue",  hex: "#3871E1" },
      { name: "Cyan",  hex: "#2EC7FF" },
      { name: "Green", hex: "#2ED47A" },
      { name: "Orange",hex: "#FF9F1C" },
      { name: "Pink",  hex: "#FF4D9D" },
      { name: "Violet",hex: "#8A5CFF" }
    ];
    let currentColor = palette[0].hex;

    const cx = 150, cy = 150;
    const radius = 140;
    const startAngle = -90;   // 12h
    const fullSweep = 360;

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    // Rejoue l’animation CSS d’un élément (utile après un changement de texte)
    function replayAnimation(el){
      if(!el) return;
      el.style.animation = 'none';
      void el.offsetHeight; // force reflow
      el.style.animation = '';
    }

    function polarToCartesian(cx, cy, r, angleDeg) {
      const a = (angleDeg - 90) * Math.PI / 180;
      return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
    }

    function describeSector(cx, cy, r, startDeg, endDeg) {
      const start = polarToCartesian(cx, cy, r, startDeg);
      const end = polarToCartesian(cx, cy, r, endDeg);
      const delta = endDeg - startDeg;
      const largeArc = delta <= 180 ? 0 : 1;

      return [
        `M ${cx} ${cy}`,
        `L ${start.x} ${start.y}`,
        `A ${r} ${r} 0 ${largeArc} 1 ${end.x} ${end.y}`,
        `Z`
      ].join(' ');
    }

    function setGauge(value){
      const v = clamp(Number(value) || 0, 0, 100);
      pctText.textContent = v + "%";

      if (v <= 0){
        fullCircle.setAttribute('opacity', '0');
        sector.setAttribute('opacity', '0');
        // animation du % quand il change
        replayAnimation(valueWrap);
        return;
      }

      if (v >= 100){
        fullCircle.setAttribute('opacity', '1');
        sector.setAttribute('opacity', '0');
        replayAnimation(valueWrap);
        return;
      }

      fullCircle.setAttribute('opacity', '0');
      sector.setAttribute('opacity', '1');

      const end = startAngle + (fullSweep * (v / 100));
      sector.setAttribute('d', describeSector(cx, cy, radius, startAngle, end));

      // rejouer l'apparition du % à chaque modif
      replayAnimation(valueWrap);
    }

    function syncValue(val){
      const v = clamp(Number(val) || 0, 0, 100);
      range.value = v;
      num.value = v;
      setGauge(v);
    }

    function syncTitle(){
      const raw = (titleInput.value || "");
      titleText.innerHTML = raw.replaceAll("\\n", "<br>");
      // rejouer l'apparition du titre à chaque modif
      replayAnimation(titleText);
    }

    function setBusy(busy, msg=""){
      btnPng.disabled = busy;
      btnJpg.disabled = busy;
      statusEl.textContent = msg;
    }

    function setColor(hex){
      currentColor = hex;
      document.documentElement.style.setProperty('--accent', hex);

      const r = parseInt(hex.slice(1,3), 16);
      const g = parseInt(hex.slice(3,5), 16);
      const b = parseInt(hex.slice(5,7), 16);
      document.documentElement.style.setProperty('--accentAlpha0', `rgba(${r}, ${g}, ${b}, 0)`);

      [...swatchesEl.querySelectorAll('.swatch')].forEach(btn => {
        btn.setAttribute('aria-selected', btn.dataset.hex === hex ? 'true' : 'false');
      });
    }

    function renderSwatches(){
      swatchesEl.innerHTML = "";
      palette.forEach((c) => {
        const b = document.createElement('button');
        b.className = "swatch";
        b.type = "button";
        b.title = c.name;
        b.dataset.hex = c.hex;
        b.style.background = c.hex;
        b.setAttribute('aria-selected', 'false');
        b.addEventListener('click', () => setColor(c.hex));
        swatchesEl.appendChild(b);
      });
      setColor(palette[0].hex);
    }

    async function exportWithHtmlToImage(kind){
      try{
        setBusy(true, "Export en cours…");

        const options = {
          pixelRatio: 2,
          cacheBust: true,
          backgroundColor: null
        };

        let dataUrl;
        if (kind === "png"){
          dataUrl = await htmlToImage.toPng(exportArea, options);
        } else {
          dataUrl = await htmlToImage.toJpeg(exportArea, { ...options, quality: 0.92 });
        }

        const a = document.createElement("a");
        const ext = kind === "png" ? "png" : "jpg";
        a.download = `infographic-${num.value}-${currentColor.replace("#","")}.${ext}`;
        a.href = dataUrl;
        document.body.appendChild(a);
        a.click();
        a.remove();

        setBusy(false, `Export terminé (${ext.toUpperCase()})`);
      }catch(e){
        console.error(e);
        setBusy(false, "Erreur export (console).");
      }
    }

    range.addEventListener('input', e => syncValue(e.target.value));
    num.addEventListener('input', e => syncValue(e.target.value));
    titleInput.addEventListener('input', syncTitle);

    btnPng.addEventListener('click', () => exportWithHtmlToImage("png"));
    btnJpg.addEventListener('click', () => exportWithHtmlToImage("jpg"));

    // Init
    renderSwatches();
    syncValue(80);
    syncTitle();
  </script>
</body>
</html>
